@name Self-Updatable Kernel/main
@model
@persist [APP_RunOnTick_Nbr]:number [URL_Str DIR_Str E2Data_Str VC_URL_Str US_URL_Str App_Directory_Str]:string
@trigger all
@autoupdate

#[ Reset Handler. ]#
if(dupefinished()){ timer("Reset", 10) }
if(clk("Reset")){ reset() }

#[ Initialize the kernel & user's application. ]#
if(first()){

    # Stop the kernel from resetting, on the first run.
    stoptimer("Reset")

    # This include is the path to your application. THIS file is what the kernel updates, when new code is made available.
    #include "e2shared/mySelfUpdatableE2/main"

    # These includes are vital for the kernel to function.
    #include "self-updatable kernel/include/config"

    # Load configs.
    APP_RunOnTick_Nbr = Kernel_Config["Run On Tick", string] == "yes" ? 1 : 0
    US_URL_Str = Kernel_Config["Update Server URL", string]
    VC_URL_Str = Kernel_Config["Version Check URL", string]

    # Initialize the user's application.
    setup()

    # Set the name of the user's application. NB: This will appear in the E2's popup window, when you look at the E2 chip in-game.
    local AppName_Str = ""

    AppName_Str += App_Config["App Author", string]
    AppName_Str += "'s\n"
    AppName_Str += App_Config["App Name", string]
    AppName_Str += "\nVersion "
    AppName_Str += App_Config["App Version", string]

    setName(AppName_Str)

    # Set execution triggers.
    runOnTick(APP_RunOnTick_Nbr)
    runOnHTTP(1)
    runOnFile(1)

    # Start an HTTP request.
    URL_Str = VC_URL_Str
    timer("Request from HTTP", 100)

}

#[ TODO: HTTP & File shit. ]#

#[ Automatic HTTP Request Handler. ]#
if(clk("Request from HTTP")){

    # Cancel the automatic request timer.
    stoptimer("Request from HTTP")

    if(httpCanRequest()){

        # Request data from the specified URL.
        httpRequest(URL_Str)

    }

    else{

        # Reset the automatic request timer.
        timer("Request from HTTP", 3000)

    }
}

#[ HTTP Callback Handler. ]#
if(httpClk()){

    # Local variables store relevant URL & HTTP data.
    local CallbackURL_Str = httpRequestUrl()
    local Data_Str = httpData()

    # Expedite version checking & automatic updates, only when data is present in the HTTP Data String.
    if(Data_Str != ""){

        # Switch-case deals with the returned HTTP data, according to which URL requested it.
        switch(CallbackURL_Str){

            # Version Check Server requested HTTP data.
            case VC_URL_Str,

                local Lines_Ary = Data_Str:explode("\n")
                local SV_Kernel_Author_Str = Lines_Ary[1, string]:explode("Author: ")[2, string]
                local SV_Kernel_Name_Str = Lines_Ary[2, string]:explode("Name: ")[2, string]
                local SV_Kernel_Version_Str = Lines_Ary[3, string]:explode("Version: ")[2, string]

                local SV_Updatable_Author_Str = Lines_Ary[5, string]:explode("Author: ")[2, string]
                local SV_Updatable_Name_Str = Lines_Ary[6, string]:explode("Name: ")[2, string]
                local SV_Updatable_Version_Str = Lines_Ary[7, string]:explode("Version: ")[2, string]

                local CFG_Kernel_Author_Str = Kernel_Config["Kernel Author", string]
                local CFG_Kernel_Name_Str = Kernel_Config["Kernel Name", string]
                local CFG_Kernel_Version_Str = Kernel_Config["Kernel Version", string]

                local CFG_Updatable_Author_Str = App_Config["App Author", string]
                local CFG_Updatable_Name_Str = App_Config["App Name", string]
                local CFG_Updatable_Version_Str = App_Config["App Version", string]

                # Invalid author's & E2's name handler.
                if(SV_Kernel_Author_Str != CFG_Kernel_Author_Str || SV_Kernel_Name_Str != CFG_Kernel_Name_Str){

                    # Invalid name & author handler.
                    print("[ERROR]: You have altered the origin of this E2's source code, & are in direct violation of its license.")
                    selfDestruct()

                }

                # What to do, when a new version of the kernel is available.
                elseif(SV_Kernel_Version_Str != CFG_Kernel_Version_Str){

                    # Print a rudimentary message to the chat.
                    print("[NOTICE]: A new version is available.")

                }

                # What to do, when a new version of the linked file is available.
                elseif(SV_Updatable_Version_Str != CFG_Updatable_Version_Str){

                    # Send an HTTP request to the update server.
                    URL_Str = US_URL_Str
                    timer("Request from HTTP", 100)

                }
                break

            # Update Server requested HTTP Data.
            case US_URL_Str,

                # Download new code from the update server & start a call to opening up the local file.
                E2Data_Str = Data_Str
                DIR_Str = App_Directory_Str
                timer("Load File", 500)
                break

            # Non-declared URL requested HTTP data.
            default,

                # This is an error, as it is not a part of the self-updating process.
                print("[ERROR]: An invalid URL tried to request HTTP data.")
                break

        }
    }

    # When no data is present in the HTTP Data Buffer, this is an error.
    else{

        # Print an error to the chat.
        print("[ERROR]: No data is present in HTTP Data Buffer.")

    }
}

#[ File Load Handler. ]#
if(clk("Load File")){

    stoptimer("Load File")

    if(fileCanLoad()){

        fileLoad(DIR_Str)

    }

    else{

        timer("Load File", 10000)

    }
}

#[ User App File Uploaded Callback Handler. ]#
if(fileClk(App_Directory_Str)){

    switch(fileStatus()){

        case _FILE_OK,
            print("[NOTICE]: User app successfully uploaded. Automatic update is now in progress...")
            timer("Update User App", 200)
            break

        default,
            print("[ERROR]: Failed to load user app.")
            break

    }
}

if(clk("Update User App")){

    stoptimer("Update User App")

    if(fileCanWrite()){

        fileWrite(App_Directory_Str, E2Data_Str)
        print("[NOTICE]: User App has been updated. E2 will now restart.")
        timer("Reset", 5000)

    }

    else{

        timer("Update User App", 200)

    }
}

#[ Execute application code. ]#
if(tickClk()){ loop() }
if(inputClk()){ inputEvent() }
